#### 题目

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

 

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1

说明:
你可以认为每种硬币的数量是无限的。



#### 解题思路

动态规划,

借鉴完全背包的解法

给定不同面额的硬币 coins 和总金额 m。每个硬币可以选择无数次。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。



状态表示

f[i][j] 为考虑前 i 种硬币，凑出金额为 j 的最少数目。
状态转移

考第 i 种硬币，我们可以不拿，或者拿 1...k 个，直到把金额拿爆。

f[i][j] = min(f[i-1]f[j], f[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)

又因为其中包含了大量的冗余计算

例如：f[i][j-c] = min(f[i-1][j-c], f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)

两者合并得到：f[i][j] = min(f[i-1]f[j], f[i][j-c]+1)

又因为f[i][j]只和上一层一个状态 (f[i-1]f[j]) 和这一层的一个状态 (f[i][j-c]+1) 有关。可以将状态优化为一维数组。

f[j] = min(f[j], f[j-c]+1)
因为金额从小到大枚举，j-c < j，所以计算 j 时， j-c 的状态已经在这一层计算好了，可以直接替换。这里与01背包问题相反。

边界情况

f[0] = 0 表示金额为0时，最小硬币凑法为0
其余要初始化为inf，因为此题要求的是恰好金额为m时的最小硬币数，所以有些状态可能达不到。



#### python3代码

```
class Solution:
    def coinChange(self, coins: List[int], m: int) -> int:
        # 利用完全背包解决问题
        f = [float('inf')] * (m + 1)
        f[0] = 0
        for c in coins:  # 枚举硬币总数
            for j in range(c, m+1):  # 从小到大枚举金额
                f[j] = min(f[j], f[j - c] + 1)
        return f[m] if f[m] != float('inf') else -1
```



****

#### C++代码

```

```

